<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

    /* General body styles - may be overridden by Elementor's global styles, which is normal */
    body {
        font-family: 'Inter', sans-serif;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #2c3e50; /* Dark blue-gray */
        color: #ecf0f1; /* Light gray text */
        overflow-y: auto; /* Allow scrolling if content truly overflows page height */
        flex-direction: column;
        padding: 20px; /* Base padding for the body */
        box-sizing: border-box;
    }

    .game-container {
        background-color: #34495e; /* Slightly lighter blue-gray */
        border-radius: 15px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        overflow: hidden; /* Keep internal content within rounded borders */
        width: 100%;
        max-width: 800px; /* Max width for desktop screens */
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px; /* Internal padding for the game container */
        box-sizing: border-box;
        position: relative;
        margin-bottom: 20px; /* Space below the container */
    }

    canvas {
        background-color: #1e2b38; /* Darker background for game area */
        display: block;
        border-radius: 10px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        width: 100%; /* Make canvas responsive to its parent width */
        /* Height is set dynamically by JavaScript in initGame() */
    }

    .game-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        padding: 10px 0;
        font-size: 1.2em;
        font-weight: bold;
    }

    .controls {
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
        flex-wrap: wrap; /* Allow buttons to wrap on small screens */
    }

    button {
        background: linear-gradient(145deg, #27ae60, #229954); /* Green gradient */
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        flex-grow: 1; /* Allow buttons to grow to fill space */
        max-width: 180px; /* Max width for individual buttons */
    }

    button:hover {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .game-message {
        position: absolute; /* Overlay effect */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 15px;
        text-align: center;
        transition: opacity 0.5s ease;
        opacity: 0;
        visibility: hidden;
        z-index: 10;
    }

    .game-message.active {
        opacity: 1;
        visibility: visible;
    }

    .message-content {
        background-color: #2c3e50;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    /* Titles within the message content (intro and game over) */
    .message-content h2 {
        font-size: 2.5em;
        margin-bottom: 10px;
        color: #e74c3c; /* Force red color for all H2s in message-content */
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); /* Subtle shadow for depth */
    }

    .message-content p {
        font-size: 1.3em;
        margin-bottom: 20px;
    }
    .message-content ul {
        list-style: none;
        padding: 0;
        margin: 20px 0;
        text-align: left;
        width: 80%; /* Adjust to center content */
        max-width: 300px; /* Limit width for readability */
    }

    .message-content ul li {
        margin-bottom: 10px;
        font-size: 1.1em;
        display: flex;
        align-items: center;
    }

    /* Styles for emojis if placed directly */
    .message-content ul li .emoji {
        margin-right: 10px;
        font-size: 1.2em; /* Slightly larger for visibility */
        line-height: 1; /* Align vertically */
        vertical-align: middle;
        text-shadow: 0 0 3px rgba(0,0,0,0.5); /* Optional: add a subtle shadow for contrast */
    }

    .message-content button {
        background: linear-gradient(145deg, #3498db, #2980b9); /* Blue gradient */
    }

    .message-content button:hover {
        background: linear-gradient(145deg, #3cb0fd, #3498db);
    }
    .visit-button {
        background: linear-gradient(145deg, #f39c12, #e67e22) !important; /* Orange gradient */
        margin-top: 15px; /* Space from other buttons/text */
        padding: 12px 25px !important; /* Match other buttons */
        border-radius: 8px; /* Match other buttons */
        font-size: 1.1em !important; /* Match other buttons */
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        flex-grow: 1; /* Allow to grow like other buttons */
        max-width: 180px; /* Match other buttons */
    }

    .visit-button:hover {
        background: linear-gradient(145deg, #e67e22, #d35400) !important;
    }


    /* Responsive adjustments */
    @media (max-width: 600px) {
        .game-container {
            padding: 15px;
        }

        .game-info {
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
        }

        .message-content h2 {
            font-size: 2em;
        }

        .message-content p {
            font-size: 1em;
        }

        .controls {
            flex-direction: column; /* Stack buttons vertically on small screens */
            align-items: stretch;
        }

        button {
            max-width: none; /* Remove max-width for stacked buttons */
        }
    }

    /* Drone and Net SVGs (for icons instead of simple shapes) */
    .player-net-gun {
        font-size: 30px; /* Adjust size as needed */
        color: #f1c40f; /* Yellow */
    }

    .net-icon {
        font-size: 15px; /* Adjust size as needed */
        color: #3498db; /* Blue */
    }
</style>

<div class="game-container">
    <div class="game-info">
        <div id="score">Score: 0</div>
        <div id="lives">Tanks: 10</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <button id="moveLeftBtn"><i class="fas fa-arrow-left"></i> Move Left</button>
        <button id="shootBtn"><i class="fas fa-crosshairs"></i> Shoot Net</button>
        <button id="moveRightBtn">Move Right <i class="fas fa-arrow-right"></i></button>
    </div>

    <div id="gameStartMessage" class="game-message active">
        <div class="message-content">
            <h2>Drone Defender</h2>
            <h3>Take aim. Fire your net. Stop the swarm.</h3>
            <p>In Drone Defender, rogue drones are swarming the battlefield, and it‚Äôs up to you to take them down before they destroy your military tanks. Armed with a powerful net launcher, you‚Äôll shoot drones right out of the sky, disabling them mid-air with precision and speed.</p>
            <ul>
                <li><span class="emoji">üõ°Ô∏è</span> Protect your tanks.</li>
                <li><span class="emoji">üéØ</span> Hone your aim.</li>
                <li><span class="emoji">üïπÔ∏è</span> Use arrow keys or buttons to move. Press spacebar or 'Shoot Net' to fire.</li>
            </ul>
            <p>Every drone you drop is one step closer to victory. How many can you stop before they break through?</p>
            <button id="startGameBtn">Start Game</button>
            <button id="visitSolidUAVsIntroBtn" class="visit-button">SOLID UAVS</button>
        </div>
    </div>

    <div id="gameOverMessage" class="game-message">
        <div class="message-content">
            <h2>Game Over!</h2>
            <p id="finalScore"></p>
            <button id="restartGameBtn">Play Again</button>
            <button id="visitSolidUAVsGameOverBtn" class="visit-button">SOLID UAVS</button>
        </div>
    </div>
</div>

<script type="module">
    // Canvas and game elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');
    const gameStartMessage = document.getElementById('gameStartMessage');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const startGameBtn = document.getElementById('startGameBtn');
    const restartGameBtn = document.getElementById('restartGameBtn');
    const finalScoreDisplay = document.getElementById('finalScore');
    const moveLeftBtn = document.getElementById('moveLeftBtn');
    const shootBtn = document.getElementById('shootBtn');
    const moveRightBtn = document.getElementById('moveRightBtn'); 

    const visitSolidUAVsIntroBtn = document.getElementById('visitSolidUAVsIntroBtn');
    const visitSolidUAVsGameOverBtn = document.getElementById('visitSolidUAVsGameOverBtn');

    // Mobile controls (declared globally but references obtained in initGame)
    let joystickArea;
    let joystickBase;
    let joystickThumb;
    let mobileShootBtn;


    let player = {
        x: 0,
        y: 0,
        width: 60,
        height: 20,
        speed: 7,
        dx: 0 // Delta x for movement
    };

    let nets = [];
    const netSpeed = 10;
    const netWidth = 15; // Initial width of the net (at its source)
    const netHeight = 30; // Height of the net

    let drones = [];
    const droneWidth = 35; // 50% smaller (original was 70)
    const droneHeight = 25; // 50% smaller (original was 50)
    const droneSpeedMin = 1;
    const droneSpeedMax = 4;
    const droneSpawnInterval = 1000; // milliseconds
    let lastDroneSpawnTime = 0;
    let propellerRotation = 0; // For drone propeller animation

    let tanks = []; // Array to hold tank objects
    const tankWidth = 50;
    const tankHeight = 30;
    const numTanks = 10; // Number of tanks
    let tanksRemaining = numTanks; // Lives are now represented by tanks

    let score = 0;
    let gameRunning = false;
    let animationFrameId;

    const trackWidth = 8; // Width of the track
    const trackOffset = 2; // Slight offset from the main body
    let tanksAreMovingIndependently = false; // Flag to trigger individual tank movement
    let trackAnimationOffset = 0; // Offset to animate the track segments
    const trackAnimationSpeed = 0.22; // Speed of track animation 

    let lastTankSurvivedTime = 0; // Timestamp when tanksRemaining becomes 1
    const difficultyRampUpDuration = 25000; // Time in ms for difficulty to fully ramp up (e.g., 25 seconds)
    const maxDroneSpeedIncrease = 1.75; // Drones will become up to 1.75x faster than normal difficulty
    const minDroneSpawnIntervalFactor = 0.5; // Spawn interval can be reduced to 50% of original

    let activeSmokePlumes = []; // Array to hold active smoke plumes
    const SMOKE_DURATION = 1500; // ms, total duration for the smoke plume
    const SMOKE_INITIAL_SIZE = 15; // Initial size of the smoke particle
    const SMOKE_MAX_SIZE = 70; // Max size the smoke plume expands to
    const SMOKE_RISE_SPEED = 0.05; // pixels per millisecond upwards movement of smoke
    
    let activeSparks = [];
    const SPARK_DURATION = 400; // ms, how long sparks last
    const SPARK_COUNT = 80; 
    const SPARK_SPEED_MAX = 15; 
    const SPARK_SIZE = 2; 

    let brokenTrackPieces = [];
    const BROKEN_TRACK_DURATION = 5000; // ms, how long broken tracks remain
    const BROKEN_TRACK_COUNT = 4; 
    const BROKEN_TRACK_SPEED_MAX = 3; 
    const BROKEN_TRACK_ROTATION_SPEED = 0.1; 

    let activeTurrets = [];
    const TURRET_LIFETIME = 3000; 
    const TURRET_INITIAL_VELOCITY_Y = -0.7; 
    const TURRET_GRAVITY = 0.01; 
    const TURRET_INITIAL_VELOCITY_X_MAX = 0.5; 
    const TURRET_ROTATION_SPEED = 0.02; 

    // Joystick variables
    let joystickActive = false;
    let joystickStartX = 0;
    let joystickStartY = 0;
    let joystickCenterX = 0;
    let joystickCenterY = 0;
    let joystickRadius = 0;

    // --- Game Initialization and Reset ---
    async function initGame() {
        // Get global element references that are dynamically added to the DOM.
        // This must be done inside initGame or window.onload to ensure they exist.
        // Moved these assignments here so they are guaranteed to exist when initGame is called.
        joystickArea = document.getElementById('joystick-area');
        joystickBase = document.getElementById('joystick-base');
        joystickThumb = document.getElementById('joystick-thumb');
        mobileShootBtn = document.getElementById('mobileShootBtn');

        canvas.width = canvas.offsetWidth; 

        const gameContainer = document.querySelector('.game-container');
        const gameInfoDiv = document.querySelector('.game-info');
        const controlsDiv = document.querySelector('.controls'); 

        const containerStyle = getComputedStyle(gameContainer);
        const containerPaddingTop = parseFloat(containerStyle.paddingTop);
        const containerPaddingBottom = parseFloat(containerStyle.paddingBottom);
        const containerMarginBottom = parseFloat(containerStyle.marginBottom);

        let totalFixedVerticalSpace = gameInfoDiv.offsetHeight + controlsDiv.offsetHeight + containerPaddingTop + containerPaddingBottom + containerMarginBottom;
        
        totalFixedVerticalSpace += parseFloat(getComputedStyle(document.body).paddingTop || 0) + parseFloat(getComputedStyle(document.body).paddingBottom || 0);

        const buffer = 20; 
        let availableHeightForCanvas = window.innerHeight - totalFixedVerticalSpace - buffer;

        const minCanvasHeight = 400; 
        canvas.height = Math.max(minCanvasHeight, availableHeightForCanvas);


        // Adjust max-height for message content dynamically based on available height
        const viewportHeight = window.innerHeight;
        const messageContentMaxHeight = viewportHeight * 0.9; 
        if (gameStartMessage && gameStartMessage.querySelector('.message-content')) {
            gameStartMessage.querySelector('.message-content').style.maxHeight = `${messageContentMaxHeight}px`;
        }
        if (gameOverMessage && gameOverMessage.querySelector('.message-content')) {
            gameOverMessage.querySelector('.message-content').style.maxHeight = `${messageContentMaxHeight}px`;
        }


        player.x = (canvas.width / 2) - (player.width / 2);
        player.y = canvas.height - player.height - tankHeight - 40; 

        nets = [];
        drones = [];
        score = 0;
        tanksRemaining = numTanks;
        updateScoreAndLives();
        lastDroneSpawnTime = Date.now();
        gameOverMessage.classList.remove('active');
        gameStartMessage.classList.add('active');
        
        gameRunning = false;
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        tanksAreMovingIndependently = false; 
        trackAnimationOffset = 0; 
        lastTankSurvivedTime = 0; 
        activeSmokePlumes = []; 
        activeSparks = []; 
        activeTurrets = []; 
        brokenTrackPieces = [];

        tanks = [];
        const totalTanksWidth = numTanks * tankWidth;
        const availableWidthForTanks = canvas.width;
        const tankSpacing = (availableWidthForTanks - totalTanksWidth) / (numTanks + 1);
        let currentTankX = tankSpacing;
        for (let i = 0; i < numTanks; i++) {
            tanks.push({
                x: currentTankX,
                y: canvas.height - tankHeight - 10, 
                width: tankWidth,
                height: tankHeight,
                intact: true,
                dx: 0 
            });
            currentTankX += tankWidth + tankSpacing;
        }

        // Initialize joystick properties after elements are ensured to exist
        if (joystickBase && joystickThumb) {
            const baseRect = joystickBase.getBoundingClientRect();
            joystickCenterX = baseRect.left + baseRect.width / 2;
            joystickCenterY = baseRect.top + baseRect.height / 2;
            joystickRadius = baseRect.width / 2;
        }
    }

    function drawPlayer() {
        ctx.font = '30px "Font Awesome 6 Free"';
        ctx.fillStyle = player.color || '#f1c40f';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('\uf6e9', player.x + player.width / 2, player.y + player.height / 2); 
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(player.x, player.y + player.height / 2, player.width, player.height / 2); 
    }

    function drawNets() {
        nets.forEach(net => {
            ctx.save();
            ctx.translate(net.x + netWidth / 2, net.y + netHeight);
            const expansionFactor = 0.25; 
            const currentNetBaseWidth = netWidth + (player.y - net.y) * expansionFactor;
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(-currentNetBaseWidth / 2, -netHeight); 
            ctx.lineTo(currentNetBaseWidth / 2, -netHeight); 
            ctx.closePath();
            ctx.fillStyle = 'rgba(52, 152, 219, 0.3)'; 
            ctx.fill();
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.strokeStyle = '#85c1e9'; 
            ctx.lineWidth = 1;
            ctx.beginPath();
            let yOffset1 = netHeight * 0.2; 
            let width1 = currentNetBaseWidth * (1 - yOffset1 / netHeight);
            ctx.moveTo(-width1 / 2, -netHeight + yOffset1);
            ctx.lineTo(width1 / 2, -netHeight + yOffset1);
            let yOffset2 = netHeight * 0.5; 
            let width2 = currentNetBaseWidth * (1 - yOffset2 / netHeight);
            ctx.moveTo(-width2 / 2, -netHeight + yOffset2);
            ctx.lineTo(width2 / 2, -netHeight + yOffset2);
            let yOffset3 = netHeight * 0.8; 
            let width3 = currentNetBaseWidth * (1 - yOffset3 / netHeight);
            ctx.moveTo(-width3 / 2, -netHeight + yOffset3);
            ctx.lineTo(width3 / 2, -netHeight + yOffset3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(0, -netHeight); 
            ctx.moveTo(0, 0);
            ctx.lineTo(-currentNetBaseWidth / 4, -netHeight); 
            ctx.moveTo(0, 0);
            ctx.lineTo(currentNetBaseWidth / 4, -netHeight); 
            ctx.stroke();
            ctx.restore();
        });
    }

    function drawDrones() {
        drones.forEach(drone => {
            ctx.save();
            ctx.translate(drone.x + drone.width / 2, drone.y + drone.height / 2);
            const bodyWidth = drone.width * 0.6; 
            const bodyHeight = drone.height * 0.5; 
            const bodyRadius = 4; 
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath();
            ctx.roundRect(-bodyWidth / 2, -bodyHeight / 2, bodyWidth, bodyHeight, bodyRadius);
            ctx.fill();
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1; 
            ctx.stroke();
            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            ctx.moveTo(0, bodyHeight / 2);
            ctx.lineTo(bodyWidth / 4, bodyHeight / 2 + 5); 
            ctx.lineTo(-bodyWidth / 4, bodyHeight / 2 + 5);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, bodyHeight / 2 + 5, 4, 0, Math.PI * 2); 
            ctx.fillStyle = '#1e2b38';
            ctx.fill();
            const armThickness = 4; 
            const armLengthBeyondBody = 10; 
            ctx.fillStyle = '#bdc3c7';
            ctx.fillRect(-bodyWidth / 2 - armLengthBeyondBody, -bodyHeight / 2 - armThickness / 2, armLengthBeyondBody, armThickness); 
            ctx.fillRect(bodyWidth / 2, -bodyHeight / 2 - armThickness / 2, armLengthBeyondBody, armThickness); 
            ctx.fillRect(-bodyWidth / 2 - armLengthBeyondBody, bodyHeight / 2 - armThickness / 2, armLengthBeyondBody, armThickness); 
            ctx.fillRect(bodyWidth / 2, bodyHeight / 2 - armThickness / 2, armLengthBeyondBody, armThickness); 
            const propellerRadius = 5; 
            const propellerBladeLength = 11; 
            function drawPropeller(x, y) {
                ctx.save();
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.arc(0, 0, propellerRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = '#7f8c8d';
                ctx.fill();
                ctx.lineWidth = 1.5; 
                ctx.strokeStyle = '#2c3e50';
                ctx.beginPath();
                ctx.rotate(propellerRotation);
                ctx.moveTo(-propellerBladeLength, 0);
                ctx.lineTo(propellerBladeLength, 0);
                ctx.moveTo(0, -propellerBladeLength);
                ctx.lineTo(0, propellerBladeLength);
                ctx.stroke();
                ctx.restore();
            }
            drawPropeller(-bodyWidth / 2 - armLengthBeyondBody / 2, -bodyHeight / 2); 
            drawPropeller(bodyWidth / 2 + armLengthBeyondBody / 2, -bodyHeight / 2); 
            drawPropeller(-bodyWidth / 2 - armLengthBeyondBody / 2, bodyHeight / 2); 
            drawPropeller(bodyWidth / 2 + armLengthBeyondBody / 2, bodyHeight / 2); 
            ctx.restore();
        });
    }

    function drawTanks() {
        tanks.forEach(tank => {
            if (!tank.intact) {
                const flameCenterX = tank.x + tank.width / 2;
                const flameCenterY = tank.y + tank.height / 2;
                const flameDrawingSize = tank.width; 
                ctx.save();
                ctx.globalAlpha = 0.3; 
                ctx.fillStyle = '#6d7b8d'; 
                ctx.fillRect(tank.x, tank.y, tank.width, tank.height); 
                ctx.restore(); 
                const flicker = Math.random() * 0.05 + 0.95; 
                ctx.fillStyle = `rgba(180, 40, 0, ${(0.7 * flicker) * 0.7})`; 
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const radius = flameDrawingSize * (0.3 + Math.random() * 0.4);
                    const xOffset = (Math.random() - 0.5) * flameDrawingSize * 0.8;
                    const yOffset = (Math.random() - 0.5) * flameDrawingSize * 0.6;
                    ctx.ellipse(flameCenterX + xOffset, flameCenterY + yOffset, radius, radius * (0.8 + Math.random() * 0.4), Math.random() * Math.PI, 0, Math.PI * 2);
                }
                ctx.fill();
                ctx.fillStyle = `rgba(240, 100, 0, ${(0.85 * flicker) * 0.7})`; 
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const radius = flameDrawingSize * (0.2 + Math.random() * 0.3);
                    const xOffset = (Math.random() - 0.5) * flameDrawingSize * 0.6;
                    const yOffset = -flameDrawingSize * 0.3 + (Math.random() - 0.5) * flameDrawingSize * 0.4;
                    ctx.ellipse(flameCenterX + xOffset, flameCenterY + yOffset, radius, radius * (0.8 + Math.random() * 0.4), Math.random() * Math.PI, 0, Math.PI * 2);
                }
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 0, ${(0.9 * flicker) * 0.7})`; 
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const radius = flameDrawingSize * (0.1 + Math.random() * 0.15);
                    const xOffset = (Math.random() - 0.5) * flameDrawingSize * 0.4;
                    const yOffset = -flameDrawingSize * 0.6 + (Math.random() - 0.5) * flameDrawingSize * 0.3;
                    ctx.ellipse(flameCenterX + xOffset, flameCenterY + yOffset, radius, radius * (0.8 + Math.random() * 0.4), Math.random() * Math.PI, 0, Math.PI * 2);
                }
                ctx.fill();
                const numSmokePuffs = 2; 
                for (let j = 0; j < numSmokePuffs; j++) {
                    const smokeSize = tankWidth * (0.05 + Math.random() * 0.05); 
                    const smokeOpacity = 0.2 + Math.random() * 0.1; 
                    const smokeParticleX = flameCenterX + (Math.random() - 0.5) * (flameDrawingSize * 0.5);
                    const smokeParticleY = flameCenterY - (flameDrawingSize * 0.1) - (Math.random() * flameDrawingSize * 0.05);
                    ctx.globalAlpha = smokeOpacity;
                    ctx.fillStyle = `rgb(44, 62, 80)`; 
                    ctx.beginPath();
                    ctx.arc(smokeParticleX, smokeParticleY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0; 
                }
            }
        });

        tanks.forEach(tank => {
            if (tank.intact) {
                ctx.fillStyle = '#6d7b8d'; 
                ctx.fillRect(tank.x, tank.y, tank.width, tank.height); 
                const trackHeight = tank.height; 
                const trackWidth = 8; 
                const trackOffset = 2; 
                ctx.fillStyle = '#4a535e'; 
                ctx.fillRect(tank.x - trackWidth - trackOffset, tank.y, trackWidth, trackHeight);
                ctx.fillRect(tank.x + tank.width + trackOffset, tank.y, trackWidth, trackHeight);
                const numSegments = 5;
                const segmentHeight = trackHeight / numSegments;
                ctx.strokeStyle = '#2c3e50'; 
                ctx.lineWidth = 1;
                for (let i = 0; i < numSegments; i++) {
                    let animatedYOffset;
                    if (tank.dx > 0) { 
                        animatedYOffset = (i * segmentHeight + trackAnimationOffset) % trackHeight;
                    } else if (tank.dx < 0) { 
                        animatedYOffset = (i * segmentHeight - trackAnimationOffset) % trackHeight;
                        if (animatedYOffset < 0) animatedYOffset += trackHeight; 
                    } else { 
                        animatedYOffset = i * segmentHeight;
                    }
                    const segmentY = tank.y + animatedYOffset;
                    ctx.beginPath();
                    ctx.roundRect(tank.x - trackWidth - trackOffset, segmentY, trackWidth, segmentHeight, 1);
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.roundRect(tank.x + tank.width + trackOffset, segmentY, trackWidth, segmentHeight, 1);
                    ctx.fill();
                    ctx.stroke();
                }
                const turretWidth = tank.width * 0.7;
                const turretHeight = tank.height * 0.5;
                const turretX = tank.x + (tank.width - turretWidth) / 2;
                const turretY = tank.y - turretHeight + 5; 
                ctx.fillStyle = '#5c6a7a'; 
                ctx.beginPath();
                ctx.roundRect(turretX, turretY, turretWidth, turretHeight, 3);
                ctx.fill();
                const cannonWidth = 8; 
                const cannonLength = 40; 
                const cannonX = turretX + turretWidth / 2 - cannonWidth / 2;
                const cannonY = turretY - cannonLength + 5; 
                ctx.fillStyle = '#4a534e'; 
                ctx.fillRect(cannonX, cannonY, cannonWidth, cannonLength);
            }
        });
    }

    function drawSmokePlumes() {
        activeSmokePlumes.forEach(plume => {
            const elapsedTime = Date.now() - plume.startTime;
            if (elapsedTime < SMOKE_DURATION) {
                const smokeProgress = elapsedTime / SMOKE_DURATION; 
                const capMaxRadius = SMOKE_MAX_SIZE * 0.6;
                const currentSmokeSize = SMOKE_INITIAL_SIZE + (SMOKE_MAX_SIZE - SMOKE_INITIAL_SIZE) * smokeProgress;
                const capCurrentRadius = currentSmokeSize * 0.7; 
                const capYOffset = -smokeProgress * (canvas.height / 3); 
                const stemWidth = currentSmokeSize * 0.2; 
                const currentSmokeOpacity = Math.max(0, 1 - smokeProgress * 1.5); 
                ctx.globalAlpha = currentSmokeOpacity;
                ctx.fillStyle = `rgb(44, 62, 80)`; 
                ctx.beginPath();
                ctx.arc(plume.x, plume.y + capYOffset, capCurrentRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(plume.x - stemWidth / 2, plume.y, stemWidth, capYOffset); 
                ctx.globalAlpha = 1.0; 
            }
        });
        activeSmokePlumes = activeSmokePlumes.filter(p => {
            const elapsedTime = Date.now() - p.startTime;
            return elapsedTime < SMOKE_DURATION;
        });
    }

    function drawSparks() {
        activeSparks.forEach(spark => {
            const elapsedTime = Date.now() - spark.startTime;
            if (elapsedTime < SPARK_DURATION) {
                const sparkProgress = elapsedTime / SPARK_DURATION; 
                const currentOpacity = 1.0 - sparkProgress;
                ctx.globalAlpha = Math.max(0, currentOpacity);
                ctx.fillStyle = spark.color; 
                ctx.beginPath();
                ctx.arc(spark.x + spark.dx * elapsedTime, spark.y + spark.dy * elapsedTime, SPARK_SIZE, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        });
        activeSparks = activeSparks.filter(s => {
            const elapsedTime = Date.now() - s.startTime;
            return elapsedTime < SPARK_DURATION;
        });
    }

    function drawFlyingTurrets() {
        activeTurrets.forEach(turret => {
            const elapsedTime = Date.now() - turret.startTime;
            if (elapsedTime < TURRET_LIFETIME) {
                const progress = elapsedTime / TURRET_LIFETIME;
                const currentOpacity = 1.0 - progress;
                ctx.save();
                ctx.globalAlpha = Math.max(0, currentOpacity);
                const currentX = turret.x + turret.dx * elapsedTime;
                const timeInSeconds = elapsedTime / 1000;
                const currentY = turret.y + turret.initialDy * elapsedTime + 0.5 * TURRET_GRAVITY * timeInSeconds * timeInSeconds;
                ctx.translate(currentX, currentY);
                ctx.rotate(turret.rotation + turret.rotationSpeed * elapsedTime);
                const turretWidth = turret.width;
                const turretHeight = turret.height;
                const turretXOffset = -turretWidth / 2;
                const turretYOffset = -turretHeight / 2;
                ctx.fillStyle = '#5c6a7a'; 
                ctx.beginPath();
                ctx.roundRect(turretXOffset, turretYOffset, turretWidth, turretHeight, 3);
                ctx.fill();
                const cannonWidth = turret.cannonWidth;
                const cannonLength = turret.cannonLength;
                const cannonXOffset = turretXOffset + turretWidth / 2 - cannonWidth / 2;
                const cannonYOffset = turretYOffset - cannonLength + 5; 
                ctx.fillStyle = '#4a535e'; 
                ctx.fillRect(cannonXOffset, cannonYOffset, cannonWidth, cannonLength);
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }
        });
        activeTurrets = activeTurrets.filter(t => {
            const elapsedTime = Date.now() - t.startTime;
            return elapsedTime < TURRET_LIFETIME;
        });
    }

    function drawBrokenTrackPieces() {
        brokenTrackPieces.forEach(piece => {
            const elapsedTime = Date.now() - piece.startTime;
            if (elapsedTime < BROKEN_TRACK_DURATION) {
                const progress = elapsedTime / BROKEN_TRACK_DURATION;
                const currentOpacity = 1.0 - progress;
                ctx.save();
                ctx.globalAlpha = Math.max(0, currentOpacity);
                const timeInSeconds = elapsedTime / 1000;
                ctx.translate(piece.x + piece.dx * elapsedTime, piece.y + piece.dy * elapsedTime + 0.5 * TURRET_GRAVITY * timeInSeconds * timeInSeconds);
                ctx.rotate(piece.rotation + piece.rotationSpeed * elapsedTime);
                ctx.fillStyle = '#4a535e'; 
                ctx.fillRect(-piece.size / 2, -piece.size / 4, piece.size, piece.size / 2);
                ctx.strokeStyle = '#3a424a';
                ctx.lineWidth = 1;
                ctx.strokeRect(-piece.size / 2, -piece.size / 4, piece.size, piece.size / 2);
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }
        });
        brokenTrackPieces = brokenTrackPieces.filter(p => {
            const elapsedTime = Date.now() - p.startTime;
            return elapsedTime < BROKEN_TRACK_DURATION;
        });
    }

    function update() {
        if (!gameRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawSmokePlumes(); 
        drawSparks();
        drawBrokenTrackPieces(); 
        drawFlyingTurrets();
        player.x += player.dx;
        if (player.x < 0) {
            player.x = 0;
        }
        if (player.x + player.width > canvas.width) {
            player.x = canvas.width - player.width;
        }
        nets = nets.filter(net => {
            net.y -= netSpeed;
            return net.y + netHeight > 0; 
        });
        let currentDroneSpawnInterval = droneSpawnInterval;
        let currentDroneSpeedMultiplier = 1;
        if (tanksRemaining === 1) {
            if (lastTankSurvivedTime === 0) { 
                lastTankSurvivedTime = Date.now();
            }
            const timeSurvivedOnLastTank = Date.now() - lastTankSurvivedTime;
            const progress = Math.min(1, timeSurvivedOnLastTank / difficultyRampUpDuration);
            currentDroneSpeedMultiplier = 1 + (maxDroneSpeedIncrease - 1) * progress;
            currentDroneSpawnInterval = droneSpawnInterval * (1 - (1 - minDroneSpawnIntervalFactor) * progress);
        }
        const currentTime = Date.now();
        if (currentTime - lastDroneSpawnTime > currentDroneSpawnInterval / (1 + score * 0.01)) { 
            spawnDrone(currentDroneSpeedMultiplier); 
            lastDroneSpawnTime = currentTime;
        }
        drones = drones.filter(drone => {
            drone.y += drone.speed;
            drone.x += drone.dx; 
            if (drone.x < 0 || drone.x + drone.width > canvas.width) {
                drone.dx *= -1; 
                if (drone.x < 0) drone.x = 0;
                if (drone.x + drone.width > canvas.width) drone.x = canvas.width - drone.width;
            }
            let droneRemoved = false;
            nets = nets.filter(net => {
                const expansionFactor = 0.25; 
                const currentNetBaseWidth = netWidth + (player.y - net.y) * expansionFactor;
                const netTipY = net.y + netHeight; 
                if (
                    !droneRemoved &&
                    drone.x < net.x + currentNetBaseWidth / 2 + netWidth / 2 && 
                    drone.x + drone.width > net.x + netWidth / 2 - currentNetBaseWidth / 2 && 
                    drone.y < netTipY && 
                    drone.y + drone.height > netTipY - netHeight 
                ) {
                    score++;
                    updateScoreAndLives();
                    droneRemoved = true;
                    return false; 
                }
                return true; 
            });
            if (droneRemoved) {
                return false; 
            }
            let hitTank = false;
            for (let i = 0; i < tanks.length; i++) {
                const tank = tanks[i];
                if (tank.intact &&
                    drone.x < tank.x + tank.width &&
                    drone.x + drone.width > tank.x &&
                    drone.y < tank.y + tank.height &&
                    drone.y + drone.height > tank.y
                ) {
                    tank.intact = false; 
                    tanksRemaining--;
                    updateScoreAndLives();
                    hitTank = true;
                    activeSmokePlumes.push({
                        x: tank.x + tank.width / 2,
                        y: tank.y + tank.height / 2,
                        startTime: Date.now()
                    });
                    const impactX = drone.x + drone.width / 2;
                    const impactY = drone.y + drone.height / 2;
                    for (let s = 0; s < SPARK_COUNT; s++) {
                        const angle = Math.random() * Math.PI * 2; 
                        const speed = Math.random() * SPARK_SPEED_MAX;
                        activeSparks.push({
                            x: impactX,
                            y: impactY,
                            dx: Math.cos(angle) * speed,
                            dy: Math.sin(angle) * speed,
                            startTime: Date.now(),
                            color: (Math.random() > 0.5) ? 'rgba(255, 255, 150, 1)' : 'rgba(255, 100, 0, 1)' 
                        });
                    }
                    const numBrokenTrackPieces = BROKEN_TRACK_COUNT;
                    const pieceSize = tankWidth * 0.15; 
                    for (let p = 0; p < numBrokenTrackPieces; p++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * BROKEN_TRACK_SPEED_MAX;
                        brokenTrackPieces.push({
                            x: impactX + (Math.random() - 0.5) * tankWidth * 0.5, 
                            y: impactY + (Math.random() - 0.5) * tankHeight * 0.5,
                            dx: Math.cos(angle) * speed,
                            dy: Math.sin(angle) * speed,
                            startTime: Date.now(),
                            rotation: Math.random() * Math.PI * 2, 
                            rotationSpeed: (Math.random() - 0.5) * BROKEN_TRACK_ROTATION_SPEED, 
                            size: pieceSize
                        });
                    }
                    const turretWidth = tank.width * 0.7;
                    const turretHeight = tank.height * 0.5;
                    const turretX = tank.x + (tank.width - turretWidth) / 2; 
                    const turretY = tank.y - turretHeight + 5; 
                    activeTurrets.push({
                        x: turretX,
                        y: turretY,
                        dx: (Math.random() - 0.5) * TURRET_INITIAL_VELOCITY_X_MAX, 
                        initialDy: TURRET_INITIAL_VELOCITY_Y - Math.random() * 0.5, 
                        startTime: Date.now(),
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * TURRET_ROTATION_SPEED,
                        width: turretWidth,
                        height: turretHeight,
                        cannonWidth: 8, 
                        cannonLength: 40
                    });
                    if (tanksRemaining <= 0) {
                        endGame();
                    }
                    break; 
                }
            }
            if (hitTank) {
                return false; 
            }
            return drone.y < canvas.height + 20; 
        });
        if (gameRunning && tanksRemaining <= numTanks / 2 && !tanksAreMovingIndependently) {
            tanksAreMovingIndependently = true; 
            tanks.forEach(tank => {
                if (tank.intact) {
                    tank.dx = (Math.random() < 0.5 ? 1 : -1) * (0.242 + Math.random() * 0.605); 
                }
            });
        }
        if (tanksAreMovingIndependently) { 
            tanks.forEach(tank => {
                if (tank.intact) {
                    tank.x += tank.dx;
                    if (tank.x - (trackWidth + trackOffset) < 0 || tank.x + tank.width + (trackWidth + trackOffset) > canvas.width) {
                        tank.dx *= -1; 
                        if (tank.x - (trackWidth + trackOffset) < 0) tank.x = trackWidth + trackOffset;
                        if (tank.x + tank.width + (trackWidth + trackOffset) > canvas.width) tank.x = canvas.width - tank.width - (trackWidth + trackOffset);
                    }
                }
            });
            trackAnimationOffset = (trackAnimationOffset + trackAnimationSpeed) % tankHeight; 
        }
        propellerRotation += 0.2; 
        if (propellerRotation > Math.PI * 2) {
            propellerRotation -= Math.PI * 2;
        }
        drawPlayer();
        drawNets();
        drawDrones();
        drawTanks(); 
        animationFrameId = requestAnimationFrame(update);
    }

    function spawnDrone(speedMultiplier = 1) { 
        const xPosition = Math.random() * (canvas.width - droneWidth);
        const speed = (droneSpeedMin + Math.random() * (droneSpeedMax - droneSpeedMin) + (score * 0.005)) * speedMultiplier; 
        let dx = 0; 
        if (Math.random() < 0.3) { 
            dx = (Math.random() < 0.5 ? 1 : -1) * (0.5 + Math.random() * 1.5) * speedMultiplier; 
        }
        drones.push({
            x: xPosition,
            y: -droneHeight, 
            width: droneWidth,
            height: droneHeight,
            speed: speed,
            dx: dx 
        });
    }

    function shootNet() {
        if (gameRunning && nets.length < 3) {
             nets.push({
                x: player.x + player.width / 2 - netWidth / 2,
                y: player.y
            });
        }
    }

    function updateScoreAndLives() {
        scoreDisplay.textContent = `Score: ${score}`;
        livesDisplay.textContent = `Tanks: ${tanksRemaining}`; 
    }

    function endGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        finalScoreDisplay.textContent = `You destroyed ${score} drones!`; 
        
        gameOverMessage.classList.add('active');
    }

    document.addEventListener('keydown', (e) => {
        if (!gameRunning && e.key !== ' ') return;
        if (e.key === ' ') {
            e.preventDefault(); 
        }
        if (e.key === 'ArrowLeft') {
            player.dx = -player.speed;
        } else if (e.key === 'ArrowRight') {
            player.dx = player.speed;
        } else if (e.key === ' ' && gameRunning) {
            shootNet();
        } else if (e.key === ' ' && !gameRunning && gameStartMessage.classList.contains('active')) {
            startGame();
        } else if (e.key === ' ' && !gameRunning && gameOverMessage.classList.contains('active')) {
            restartGame();
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            player.dx = 0;
        }
    });

    // Handle desktop control buttons
    if (moveLeftBtn) {
        moveLeftBtn.addEventListener('mousedown', () => { if (gameRunning) player.dx = -player.speed; });
        moveLeftBtn.addEventListener('mouseup', () => { if (gameRunning) player.dx = 0; });
        moveLeftBtn.addEventListener('mouseleave', () => { if (gameRunning) player.dx = 0; });
    }

    if (moveRightBtn) {
        moveRightBtn.addEventListener('mousedown', () => { if (gameRunning) player.dx = player.speed; });
        moveRightBtn.addEventListener('mouseup', () => { if (gameRunning) player.dx = 0; });
        moveRightBtn.addEventListener('mouseleave', () => { if (gameRunning) player.dx = 0; });
    }

    if (shootBtn) {
        shootBtn.addEventListener('click', () => { if (gameRunning) shootNet(); });
    }

    // Handle mobile joystick and shoot button
    let touchIdentifier = null; 
    
    function handleJoystickMove(e) {
        const touch = e.changedTouches[0];
        const currentX = touch.clientX;
        const currentY = touch.clientY;

        let deltaX = currentX - joystickCenterX;
        let deltaY = currentY - joystickCenterY;

        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        if (distance > joystickRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = joystickRadius * Math.cos(angle);
            deltaY = joystickRadius * Math.sin(angle);
        }

        joystickThumb.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        player.dx = (deltaX / joystickRadius) * player.speed;
    }

    // Event listeners for mobile controls attached after DOMContentLoaded
    document.addEventListener('DOMContentLoaded', () => {
        // Assign elements to global variables after DOM is loaded
        joystickArea = document.getElementById('joystick-area');
        joystickBase = document.getElementById('joystick-base');
        joystickThumb = document.getElementById('joystick-thumb');
        mobileShootBtn = document.getElementById('mobileShootBtn');

        if (joystickArea && joystickBase && joystickThumb && mobileShootBtn) { 
            joystickArea.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                e.preventDefault(); 
                const touch = e.changedTouches[0];
                joystickActive = true;
                touchIdentifier = touch.identifier; 
                const baseRect = joystickBase.getBoundingClientRect(); 
                joystickCenterX = baseRect.left + baseRect.width / 2;
                joystickCenterY = baseRect.top + baseRect.height / 2;
                joystickRadius = baseRect.width / 2;
                handleJoystickMove(e); 
            });

            joystickArea.addEventListener('touchmove', (e) => {
                if (!gameRunning || !joystickActive) return;
                e.preventDefault(); 
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdentifier) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return; 
                handleJoystickMove(e);
            });

            joystickArea.addEventListener('touchend', (e) => {
                if (!gameRunning || !joystickActive) return;
                let touchEnded = false;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchIdentifier) {
                        touchEnded = true;
                        break;
                    }
                }
                if (!touchEnded) return; 
                joystickActive = false;
                touchIdentifier = null;
                player.dx = 0; 
                joystickThumb.style.transform = `translate(0, 0)`; 
            });

            mobileShootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                if (gameRunning) {
                    shootNet();
                }
            });
        }

        startGameBtn.addEventListener('click', startGame);
        restartGameBtn.addEventListener('click', restartGame);

        visitSolidUAVsIntroBtn.addEventListener('click', () => {
            window.open('https://soliduavs.com/', '_blank');
        });

        visitSolidUAVsGameOverBtn.addEventListener('click', () => {
            window.open('https://soliduavs.com/', '_blank');
        });

        initGame(); // Call initGame after all elements are loaded and assigned
    });

    function startGame() {
        gameStartMessage.classList.remove('active');
        gameOverMessage.classList.remove('active'); 
        gameRunning = true;
        lastDroneSpawnTime = Date.now();
        update(); 
    }

    function restartGame() {
        initGame(); 
        startGame(); 
    }

    window.addEventListener('resize', initGame);
</script>
